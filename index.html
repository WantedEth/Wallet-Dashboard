<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wallet Dashboard Â· Multi-Chain (Enhanced)</title>
<style>
/* Same deep professional theme you had, with small additions */
body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background:#0e1220; color:#e6eef8; margin:0; padding:18px;}
h1 {text-align:center; color:#58d1ff; margin-bottom:14px; text-shadow:0 0 8px #00bfff;}
.controls {display:flex; flex-wrap:wrap; gap:8px; margin-bottom:12px; align-items:center;}
.controls input[type=text], .controls input[type=file], button, .controls select {padding:10px; border-radius:8px; border:1px solid #233044; background:#121826; color:#e6eef8; min-width:140px; flex:1;}
button {background:#00a7ff; cursor:pointer; border:none;}
button:hover {background:#008ed6;}
table {width:100%; border-collapse:collapse; background:#0f1826; margin-top:8px; border-radius:10px; overflow:hidden;}
th, td {padding:10px 8px; border-bottom:1px solid #1f2b3b; text-align:center; font-size:13px; white-space:nowrap;}
th {background:#08101a; color:#7fe6ff; position:sticky; top:0; z-index:5;}
tbody tr:hover {background:#162434;}
.chain-native { font-weight:700; }
.eth { color:#b58bff } .bsc { color:#ffd97a } .poly { color:#6effd4 } .base { color:#ff8b8b }
.small { font-size:12px; color:#bcd4ea; }
.indicator { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }
.green { background:#2ecc71 } .orange { background:#f39c12 } .red { background:#e74c3c }
.page-controls { text-align:center; margin-top:12px; }
.pagination button{ margin:0 6px; padding:6px 12px; border-radius:6px; }
.token-list { text-align:left; max-height:200px; overflow:auto; padding:6px; background:#09111a; border-radius:6px; margin-top:6px; }
.token-item { padding:6px 4px; border-bottom:1px dashed #12202b; }
.controls-row { display:flex; gap:8px; width:100%; }
@media(max-width:780px){ .controls-row{ flex-direction:column } table{ font-size:12px } }
</style>
</head>
<body>

<h1>ðŸ’Ž Wallet Dashboard Â· Multi-Chain (Enhanced)</h1>

<div class="controls controls-row">
  <input id="fileInput" type="file" accept=".txt" />
  <button id="loadFile">Load wallets.txt</button>
  <input id="search" type="text" placeholder="Search address..." />
  <select id="pageSizeSelect">
    <option value="50">50 / page</option>
    <option value="100" selected>100 / page</option>
    <option value="200">200 / page</option>
  </select>
  <label class="small"><input id="autoRefreshToggle" type="checkbox" checked /> Auto refresh (5s)</label>
</div>

<div class="controls">
  <label class="small"><input id="filterBal" type="checkbox" /> Non-zero</label>
  <label class="small"><input id="filterTx" type="checkbox" /> Has tx</label>
  <button id="exportCsv">Export CSV</button>
  <div style="flex:1;text-align:right" class="small">Price source: CoinGecko â€¢ API: Etherscan V2</div>
</div>

<table>
<thead>
<tr>
  <th>Address</th>
  <th class="eth">ETH (native)</th>
  <th class="eth">ETH tx</th>
  <th class="eth">ERC20 tokens</th>
  <th class="bsc">BNB (native)</th>
  <th class="bsc">BNB tx</th>
  <th class="bsc">BEP20 tokens</th>
  <th class="poly">Polygon (native)</th>
  <th class="poly">Polygon tx</th>
  <th class="poly">ERC20 tokens</th>
  <th class="base">Base (native)</th>
  <th class="base">Base tx</th>
  <th class="base">ERC20 tokens</th>
  <th>Total USD</th>
  <th>Avg gas</th>
  <th>Activity</th>
</tr>
</thead>
<tbody id="table-body">
  <tr><td colspan="16" class="small">No wallets loaded</td></tr>
</tbody>
</table>

<div class="page-controls">
  <button id="prev">Prev</button>
  <span id="pageInfo">Page 0 / 0</span>
  <button id="next">Next</button>
</div>

<script>
/*
  Enhanced dashboard logic:
  - Uses Etherscan V2 central endpoint for all chains (single API key).
  - Uses CoinGecko public API for prices (ETH, BNB, Polygon, Base + tokens if available).
  - Fetches:
      - native balance via V2 account.balance
      - txlist (normal txs) via V2 module=account action=txlist (we fetch up to offsetLimit items)
      - token transfers via V2 module=account action=tokentx (we fetch up to offsetLimit items)
  - Computes token balances per wallet by aggregating tokentx (in/out)
  - Calculates avg gas used from normal txs (gasUsed field)
  - Auto-refresh every 5s (toggleable)
  - Batching/delay between wallet requests to reduce rate-limit problems (adjustable)
*/

const API_KEY = "VUZQ4R438NJG2FHZTAF1CZTXMGEUI8DPSF"; // your key
const V2_BASE = "https://api.etherscan.io/v2/api";    // Etherscan V2 central endpoint

// chain names used by V2
const CHAIN_NAMES = { ETH: "eth", BSC: "bsc", POLY: "polygon", BASE: "base" };

// UI elements
const fileInput = document.getElementById("fileInput");
const loadFileBtn = document.getElementById("loadFile");
const tableBody = document.getElementById("table-body");
const searchInput = document.getElementById("search");
const prevBtn = document.getElementById("prev");
const nextBtn = document.getElementById("next");
const pageInfo = document.getElementById("pageInfo");
const pageSizeSelect = document.getElementById("pageSizeSelect");
const autoRefreshToggle = document.getElementById("autoRefreshToggle");
const filterBal = document.getElementById("filterBal");
const filterTx = document.getElementById("filterTx");
const exportCsvBtn = document.getElementById("exportCsv");

// data
let addresses = [];
let walletData = []; // array of {addr, eth:{balance,txCount,tokens,avgGas}, bsc:..., poly:..., base:..., totalUSD, indicator}
let currentPage = 1;
let pageSize = parseInt(pageSizeSelect.value);

// configuration & limits
const offsetLimit = 1000;      // max txs/tokentx we request per call (page size)
const perWalletDelay = 220;    // ms delay between wallets to reduce quick bursts (adjust if hitting rate limits)
const autoRefreshMs = 5000;    // 5 seconds

let autorefreshIntervalId = null;

// helper: sleep
const sleep = (ms) => new Promise(res => setTimeout(res, ms));

// Helper: safe JSON parse
async function fetchJson(url) {
  try {
    const r = await fetch(url);
    return await r.json();
  } catch (e) {
    return null;
  }
}

// Build V2 endpoint URL
function v2Url(chain, moduleActionParams) {
  // Example: `${V2_BASE}?chain=eth&module=account&action=balance&address=...&apikey=KEY`
  return `${V2_BASE}?chain=${chain}&${moduleActionParams}&apikey=${API_KEY}`;
}

// Get native balance via V2
async function fetchBalance(chain, addr) {
  const url = v2Url(chain, `module=account&action=balance&address=${addr}`);
  const j = await fetchJson(url);
  if (!j || !j.result) return 0;
  return Number(j.result) / 1e18;
}

// Get normal transaction list (we request offsetLimit recent txs â€” good for averages/counts)
async function fetchTxList(chain, addr) {
  const url = v2Url(chain, `module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&page=1&offset=${offsetLimit}&sort=desc`);
  const j = await fetchJson(url);
  if (!j || !Array.isArray(j.result)) return [];
  return j.result;
}

// Get token transfer history (tokentx)
async function fetchTokenTx(chain, addr) {
  const url = v2Url(chain, `module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&page=1&offset=${offsetLimit}&sort=desc`);
  const j = await fetchJson(url);
  if (!j || !Array.isArray(j.result)) return [];
  return j.result;
}

// Aggregate token balances from tokentx array
function aggregateTokenBalances(tokentxArray, addr) {
  // tokentx entries include: tokenSymbol, tokenDecimal, value, from, to, contractAddress
  const map = {}; // contract -> { symbol, decimals, balance (as BigInt scaled) }
  const lcAddr = addr.toLowerCase();

  for (const t of tokentxArray) {
    const contract = (t.contractAddress || t.tokenAddress || "").toLowerCase();
    if (!contract) continue;
    const dec = Number(t.tokenDecimal || 0);
    const sym = t.tokenSymbol || contract.slice(0,6);

    // value may be string of integer in smallest unit
    const valStr = t.value || "0";
    // treat as BigInt-like arithmetic using JS BigInt if available
    // Convert to BigInt
    let valBig;
    try { valBig = BigInt(valStr.toString()); } catch(e) { valBig = BigInt(0); }

    // determine direction: if tx.to == this addr => +, if tx.from == this addr => -
    const isIn = (t.to || "").toLowerCase() === lcAddr;
    const isOut = (t.from || "").toLowerCase() === lcAddr;

    if (!map[contract]) map[contract] = { symbol: sym, decimals: dec, balance: BigInt(0), contract };
    if (isIn && !isOut) {
      map[contract].balance += valBig;
    } else if (isOut && !isIn) {
      map[contract].balance -= valBig;
    } else if (isIn && isOut) {
      // internal transfer (same address) â€” ignore
    } else {
      // Could be logs unrelated; check topics? skip
    }
  }

  // convert to float numbers using decimals
  const tokens = [];
  for (const k in map) {
    const entry = map[k];
    // convert BigInt to number with decimals safely (may lose precision for huge numbers, but fine for display)
    const denom = 10n ** BigInt(entry.decimals || 0);
    let floatVal = 0;
    if (denom > 0n) {
      // produce string decimal
      const integerPart = entry.balance / denom;
      const fractional = entry.balance % denom;
      const fracStr = fractional.toString().padStart(Number(entry.decimals||0),'0').replace(/0+$/,'');
      floatVal = Number(integerPart.toString() + (fracStr ? '.' + fracStr.slice(0,6) : ''));
    } else {
      floatVal = Number(entry.balance.toString());
    }
    // Round to sensible decimals
    floatVal = Math.round(floatVal * 1e6) / 1e6;
    if (floatVal !== 0) {
      tokens.push({ contract: entry.contract, symbol: entry.symbol, decimals: entry.decimals, balance: floatVal });
    }
  }
  return tokens;
}

// Fetch USD prices for native coins and tokens via CoinGecko
// We'll map: ethereum, binancecoin, polygon, base
async function fetchPrices(symbols) {
  // symbols is array of coin ids or token contract addresses
  // We'll call CoinGecko simple/price for main coins and contract endpoints for tokens on ethereum
  const prices = {}; // key -> usd
  try {
    // native coins
    const coinIds = ['ethereum','binancecoin','polygon','base']; // note: 'base' may exist on Coingecko; if not returns undefined
    const q = `https://api.coingecko.com/api/v3/simple/price?ids=${coinIds.join(',')}&vs_currencies=usd`;
    const j = await fetchJson(q);
    if (j) {
      if (j.ethereum) prices['ETH'] = j.ethereum.usd;
      if (j.binancecoin) prices['BNB'] = j.binancecoin.usd;
      if (j.polygon) prices['POLY'] = j.polygon.usd;
      if (j.base) prices['BASE'] = j.base.usd;
    }
  } catch(e) {
    // ignore
  }
  return prices;
}

// Compute activity indicator
function computeIndicator(totalUsd, totalTxCount, avgGas) {
  // simple rules:
  // green: totalUsd >= $10 or totalTxCount >= 10
  // orange: totalUsd > 0 or totalTxCount > 0
  // red: both zero
  if ((totalUsd || 0) >= 10 || (totalTxCount || 0) >= 10) return 'green';
  if ((totalUsd || 0) > 0 || (totalTxCount || 0) > 0) return 'orange';
  return 'red';
}

// worker to fetch all data for a single wallet (all chains)
async function processWallet(addr) {
  const result = { addr };

  // fetch native balances in parallel
  const [ethBal, bscBal, polyBal, baseBal] = await Promise.all([
    fetchBalance(CHAIN_NAMES.ETH, addr),
    fetchBalance(CHAIN_NAMES.BSC, addr),
    fetchBalance(CHAIN_NAMES.POLY, addr),
    fetchBalance(CHAIN_NAMES.BASE, addr),
  ]);
  result.eth = { balance: ethBal || 0 };
  result.bsc = { balance: bscBal || 0 };
  result.poly = { balance: polyBal || 0 };
  result.base = { balance: baseBal || 0 };

  // fetch normal txs and token txs for each chain (limited by offsetLimit)
  // We'll do them sequentially per chain to avoid bursts
  for (const [chainKey, chainName] of Object.entries(CHAIN_NAMES)) {
    // normal txs
    const txs = await fetchTxList(chainName, addr).catch(()=>[]);
    const tokenTxs = await fetchTokenTx(chainName, addr).catch(()=>[]);

    // compute txCount = number of normal txs (we have up to offsetLimit results)
    const txCount = (Array.isArray(txs) ? txs.length : 0);
    // compute avg gas used from txs
    let avgGas = null;
    if (Array.isArray(txs) && txs.length) {
      // gasUsed field may exist (from V2 txlist). Use gasUsed numeric
      let sum = 0;
      let count = 0;
      for (const t of txs) {
        const gu = Number(t.gasUsed || t.gas || 0);
        if (!isNaN(gu)) { sum += gu; count++; }
      }
      if (count>0) avgGas = Math.round((sum / count));
    }

    // aggregate token balances from tokenTxs
    const tokens = aggregateTokenBalances(Array.isArray(tokenTxs) ? tokenTxs : [], addr);

    // attach to result object
    if (chainKey === 'ETH') {
      result.eth.txCount = txCount;
      result.eth.avgGas = avgGas;
      result.eth.tokens = tokens;
    } else if (chainKey === 'BSC') {
      result.bsc.txCount = txCount;
      result.bsc.avgGas = avgGas;
      result.bsc.tokens = tokens;
    } else if (chainKey === 'POLY') {
      result.poly.txCount = txCount;
      result.poly.avgGas = avgGas;
      result.poly.tokens = tokens;
    } else if (chainKey === 'BASE') {
      result.base.txCount = txCount;
      result.base.avgGas = avgGas;
      result.base.tokens = tokens;
    }

    // small delay between chains
    await sleep(80);
  }

  // compute total USD value using CoinGecko prices (native + tokens)
  // fetch prices (only native coins here for speed). Token USD we'll attempt via contract->coingecko if needed (not implemented fully).
  const prices = await fetchPrices();
  const ethPrice = prices['ETH'] || 0;
  const bnbPrice = prices['BNB'] || 0;
  const polyPrice = prices['POLY'] || 0;
  const basePrice = prices['BASE'] || 0;

  // native totals
  const nativeUsd = (result.eth.balance || 0) * (ethPrice || 0)
                  + (result.bsc.balance || 0) * (bnbPrice || 0)
                  + (result.poly.balance || 0) * (polyPrice || 0)
                  + (result.base.balance || 0) * (basePrice || 0);

  // token totals: we don't have reliable contract->coingecko mapping offline, so sum is approximate (0 if no price)
  let tokensUsd = 0;
  // For now, we'll attempt to add token USD only for tokens if we can fetch price by contract on Coingecko (ethereum platform)
  // But to avoid many requests, we skip token price lookup â€” set tokensUsd = 0 (you can add per-token lookup if desired)
  result.totalUSD = Math.round((nativeUsd + tokensUsd) * 100) / 100;

  // compute avgGas overall across chains (weighted)
  const avgGases = [result.eth.avgGas, result.bsc.avgGas, result.poly.avgGas, result.base.avgGas].filter(v=>typeof v === 'number');
  result.avgGas = avgGases.length ? Math.round(avgGases.reduce((a,b)=>a+b,0)/avgGases.length) : null;

  // total tx count
  const totalTxCount = (result.eth.txCount||0) + (result.bsc.txCount||0) + (result.poly.txCount||0) + (result.base.txCount||0);
  result.totalTxCount = totalTxCount;

  // indicator color
  result.indicator = computeIndicator(result.totalUSD, totalTxCount, result.avgGas);

  return result;
}

// Render wallet table page
function renderTable() {
  // apply search & filters, paginated
  const q = (searchInput.value || "").toLowerCase();
  const filterNonZero = filterBal.checked;
  const filterHasTx = filterTx.checked;

  const filtered = walletData.filter(w => {
    if (q && !w.addr.toLowerCase().includes(q)) return false;
    const totalBal = (w.eth.balance||0) + (w.bsc.balance||0) + (w.poly.balance||0) + (w.base.balance||0);
    const totalTx = (w.totalTxCount||0);
    if (filterNonZero && totalBal === 0) return false;
    if (filterHasTx && totalTx === 0) return false;
    return true;
  });

  const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
  if (currentPage > totalPages) currentPage = totalPages;

  const start = (currentPage - 1) * pageSize;
  const page = filtered.slice(start, start + pageSize);

  // build rows
  tableBody.innerHTML = '';
  if (!page.length) {
    tableBody.innerHTML = `<tr><td colspan="16" class="small">No wallets to display</td></tr>`;
    pageInfo.innerText = `Page ${currentPage} / ${totalPages}`;
    return;
  }

  for (const w of page) {
    // prepare token summary counts
    const ethTokensCount = (w.eth.tokens ? w.eth.tokens.length : 0);
    const bscTokensCount = (w.bsc.tokens ? w.bsc.tokens.length : 0);
    const polyTokensCount = (w.poly.tokens ? w.poly.tokens.length : 0);
    const baseTokensCount = (w.base.tokens ? w.base.tokens.length : 0);

    // create token list HTML small (click to expand)
    const createTokenHtml = (tokens) => {
      if (!tokens || tokens.length === 0) return '-';
      // show up to 3 tokens summary
      const first = tokens.slice(0,3).map(t => `${t.symbol}: ${t.balance}`).join(' â€¢ ');
      const more = tokens.length > 3 ? ` +${tokens.length-3} more` : '';
      return `<div class="small">${first}${more}</div>`;
    };

    const totalUsd = (w.totalUSD != null) ? `$${w.totalUSD.toLocaleString()}` : 'N/A';
    const avgGas = w.avgGas == null ? '-' : `${w.avgGas}`;

    tableBody.innerHTML += `
      <tr>
        <td style="text-align:left; font-family:monospace">${w.addr}</td>

        <td class="eth">${(w.eth.balance||0).toFixed(6)}</td>
        <td class="eth">${w.eth.txCount||0}</td>
        <td class="eth">${createTokenHtml(w.eth.tokens)}</td>

        <td class="bsc">${(w.bsc.balance||0).toFixed(6)}</td>
        <td class="bsc">${w.bsc.txCount||0}</td>
        <td class="bsc">${createTokenHtml(w.bsc.tokens)}</td>

        <td class="poly">${(w.poly.balance||0).toFixed(6)}</td>
        <td class="poly">${w.poly.txCount||0}</td>
        <td class="poly">${createTokenHtml(w.poly.tokens)}</td>

        <td class="base">${(w.base.balance||0).toFixed(6)}</td>
        <td class="base">${w.base.txCount||0}</td>
        <td class="base">${createTokenHtml(w.base.tokens)}</td>

        <td>${totalUsd}</td>
        <td>${avgGas}</td>
        <td><span class="indicator ${w.indicator}"></span><span class="small">${w.indicator}</span></td>
      </tr>
    `;
  }

  pageInfo.innerText = `Page ${currentPage} / ${totalPages}`;
}

// Main: load wallets from array addresses, batch process with delay
async function loadAllWallets() {
  walletData = [];
  tableBody.innerHTML = `<tr><td colspan="16" class="small">Loading wallets... (${addresses.length})</td></tr>`;
  currentPage = 1;

  for (let i = 0; i < addresses.length; i++) {
    const addr = addresses[i];
    try {
      const w = await processWallet(addr);
      walletData.push(w);
    } catch (e) {
      walletData.push({ addr, eth:{balance:0,txCount:0,tokens:[]}, bsc:{balance:0,txCount:0,tokens:[]}, poly:{balance:0,txCount:0,tokens:[]}, base:{balance:0,txCount:0,tokens:[]}, totalUSD:0, avgGas:null, indicator:'red', totalTxCount:0});
    }
    // re-render incrementally so user sees progress
    renderTable();
    await sleep(perWalletDelay); // throttle between wallet calls
  }

  renderTable();
}

// File load handler
loadFileBtn.addEventListener('click', ()=> {
  const f = fileInput.files[0];
  if (!f) return alert("Please select addresses.txt first (one address per line).");
  const reader = new FileReader();
  reader.onload = (ev) => {
    addresses = ev.target.result.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    currentPage = 1;
    pageSize = Number(pageSizeSelect.value);
    loadAllWallets();
  };
  reader.readAsText(f);
});

// pagination handlers
prevBtn.addEventListener('click', ()=> { if (currentPage>1) { currentPage--; renderTable(); }});
nextBtn.addEventListener('click', ()=> { currentPage++; renderTable(); });

// filters, search, page size
searchInput.addEventListener('input', ()=> { currentPage=1; renderTable(); });
filterBal.addEventListener('change', ()=> { currentPage=1; renderTable(); });
filterTx.addEventListener('change', ()=> { currentPage=1; renderTable(); });
pageSizeSelect.addEventListener('change', ()=> { pageSize = Number(pageSizeSelect.value); currentPage=1; renderTable(); });

// export CSV
exportCsvBtn.addEventListener('click', ()=> {
  if (!walletData.length) return alert("No data to export.");
  const rows = [];
  rows.push(['address','eth_balance','eth_tx','eth_tokens','bnb_balance','bnb_tx','bnb_tokens','poly_balance','poly_tx','poly_tokens','base_balance','base_tx','base_tokens','total_usd','avg_gas','indicator']);
  for (const w of walletData) {
    const row = [
      w.addr,
      (w.eth.balance||0),
      (w.eth.txCount||0),
      (w.eth.tokens||[]).map(t=>`${t.symbol}:${t.balance}`).join('|'),
      (w.bsc.balance||0),
      (w.bsc.txCount||0),
      (w.bsc.tokens||[]).map(t=>`${t.symbol}:${t.balance}`).join('|'),
      (w.poly.balance||0),
      (w.poly.txCount||0),
      (w.poly.tokens||[]).map(t=>`${t.symbol}:${t.balance}`).join('|'),
      (w.base.balance||0),
      (w.base.txCount||0),
      (w.base.tokens||[]).map(t=>`${t.symbol}:${t.balance}`).join('|'),
      (w.totalUSD||0),
      (w.avgGas||''),
      (w.indicator||'')
    ];
    rows.push(row);
  }
  const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'wallets_export.csv'; a.click();
  URL.revokeObjectURL(url);
});

// Auto refresh
function startAutoRefresh() {
  if (autorefreshIntervalId) clearInterval(autorefreshIntervalId);
  if (!autoRefreshToggle.checked) return;
  autorefreshIntervalId = setInterval(async () => {
    // reprocess addresses quickly â€” for performance we only refresh balances + small tx fetch
    // Here we simply reload everything (could be optimized to refresh only balances)
    await loadAllWallets();
  }, autoRefreshMs);
}
autoRefreshToggle.addEventListener('change', ()=> {
  startAutoRefresh();
});
startAutoRefresh();

</script>
</body>
</html>
